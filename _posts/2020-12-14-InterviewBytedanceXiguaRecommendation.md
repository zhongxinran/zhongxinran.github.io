---
title: 面经 | 字节推荐算法工程师 2020-12
author: 钟欣然
date: 2020-12-14 00:44:00 +0800
categories: [面经, 推荐算法]
math: true
mermaid: true
---

# 一面

1. 【算法】快速排序
2. 【算法】找出需要排序的部分的首尾索引
3. 【算法】n个绳子围成若干个圈
4. 【问题分析】视频软件中有不同品类的视频（如影视、体育、生活等），一定有一些品类供大于求，有一些品类供小于求，从哪些角度或指标去分析这个问题，怎样从推荐的角度理解供求关系；如果我们在某一段时间里对某个品类的视频做了更多的推荐，怎样判断喜欢这个品类的人有没有变多（提示：找到基准用户群，比较比这个用户群更喜欢这个品类的用户的比例）

# 二面

1. 【算法】数组划分的价值
2. 【算法】字符串排序后，根据末尾字母恢复原字符串
3. 【过去经历】字节数据开发实习中用户增长方面，目标是什么，指标是什么，有什么结论，结论有什么应用

# HR面

1. 入职时间、实习时长、每周出勤情况等；
2. 大小周是否能接受；
3. 转正意愿、职业规划（专业不契合）等；
4. 上一段实习中的收获、困难、leader评价等；
5. 有没有参与过实验室项目，导师是谁；

# 附录

## 找出需要排序的部分的首尾索引

> 给定一个互不重复的整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是升序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是升序的），请返回[-1,-1]。

> 示例：
[1, 2, 3, 4, 5] 返回 [-1, -1]
[1, 2, 5, 3, 4] 返回 [2, 4]
[1, 2, 5, 7, 6, 1, 9, 6, 3, 4, 8, 11] 返回 [2, 11]

**解法：** 从头往后找到第一个倒序中第一个元素的索引 i，从后往前找到第一个倒序对中第二个元素的索引 j，取序列 i 和 j 之间的最大值和最小值，再从 i 往前找到比最小值小的索引，从 j 往后找到比最大值大的索引，返回这两个值。注意找最大值和最小值的这一步，是一开始没有想到的。

```python
class Solution:
    def sortIndex(self, lst:list):
        if len(lst) <= 1:
            return [-1, -1]
        
        i, j = 0, len(lst)-1
        while i < len(lst)-1 and lst[i] <= lst[i+1]:
            i += 1
        if i == len(lst)-1:
            return [-1, -1]
        
        while j > 0 and lst[j] >= lst[j-1]:
            j -= 1
        
        left_margin, right_margin = min(lst[i:(j+1)]), max(lst[i:[j+1]])
        
        while i >= 0 and lst[i] > left_margin:
            i -= 1
        while j <= len(lst)-1 and lst[j] < right_margin:
            j += 1
        return [i+1, j-1]
```

## n个绳子围成若干个圈

> n根绳子，每根颜色互不相同，每根绳子的两端也互不相同。要将其中的某些绳子连接成若干个圈（一根绳子自己首尾相连也视为一个圈），问有多少种不同的方法。

**解法：** 递归的方法，n个绳子和n-1个绳子相比，第n个绳子可以自己围成一个圈，也可以分别用第n个绳子的头部、尾部和n-1跟绳子中的每个绳子的尾部相连，视作一根绳子。注意是可以围成若干个圈，而不只是围成一个圈。

## 数组划分的价值

> 给定包含n个元素的数组，将其分割为m段，对每一段的和取最大值，即为这种划分的价值。求一种划分，使得对这个数组而言，这种划分的价值最小。

> 示例：数组[5, 1, 4,  2, 3]，可以划分为 5 | 1 4 | 2 3，各段和分别为 5 5 5，这种划分的价值为5，也可以划分为 5 1 | 4 2 | 3，各段和分别为 6 6 3，这种划分的价值为6，对这个数组，划分的价值最小即为5。

**解法：** 动态规划，$F_{ij}$表示对长度为 i 的数组A做 j 次划分的价值，则对长度为 i 的数组做 j 次划分可以视为将每次将最后一个元素自己作为一段、和前面一个元素作为一段、和前面两个元素作为一段……前面剩下的元素们做 j-1 次划分，即价值为将前 p 个元素做 j-1 次划分的价值和p+1到n的元素求和取大，再对所有的p取最小。
$$F_{ij} = min_{p\in [j,i-1]}\{max\{F_{p(j-1)},\sum_{k=p+1}^iA_k\}\}$$

其它想法：给定一个数P，问是否存在一种划分，使得这个划分的价值不超过P。基于贪心算法，每次找最长的和不超过P的序列，看划分M次后是否用完序列中的所有元素。需证明贪心算法是有效的，即任意一种不能被贪心算法找出的划分都不符合题意，证明思路为基于贪心的划分，其中每一段往后多纳入一个元素，这段的和都会超过P，往前多纳入一个元素也许不会超过P，但是最后剩下的那些元素还是没有被塞入任何一段中，减少一个或多个元素，也会导致更多的未被塞入任何一段的元素，因此贪心算法是有效的。

基于以上提示，提出了以下想法，但都行不通：

- 对序列的第一个元素、前两个元素的和、前三个元素的和…依次校验是否存在一种划分，使得这个划分的价值不超过这个和（暗含了划分的价值一定是第一段的和，不合题意）
- 对序列的最大值W，校验是否存在一种划分，使得这个划分的价值不超过W，如不存在，找到最大值的邻居，对邻居中最小的和W求和，检验是否存在一种划分使得划分的最大值不超过这个和，依次校验下去（暗含了划分的价值一定是包含最大值那段的和，不合题意）
- 找出序列最大值W，依次校验是否存在一种划分，使得这个划分的价值不超过W、W+1、W+2…，最多校验到nW，一定能找到一个解（复杂度过高）

## 字符串排序后，根据末尾字母恢复原字符串

> 给定一个N个字符串的序列，如N=4时，给定序列ACBD，每次可以把这个序列最开头的元素挪到末尾，得到
ACBD
CBDA
BDAC
DACB
对这四个序列排序，得到
ACBD
BDAC
CBDA
DACB
如果仅给定排序后序列的最后一位的字母，即DCAB，能否还原出原序列（ACBD、CBDA、BDAC、DACB均可）

**解法：** 首先容易想到，对末尾字母排序，即为对应的N个序列的开头，即有
AxxD
BxxC
CxxA
DxxB
即原序列中，D后面是A，C后面是B，A后面是C，B后面是D，找到长度为2的子串，对没有重复字符的字符串，到此处即可恢复。

对有重复字符的字符串，如ABABCC，这种方法行不通，进一步思路为找到长度为2的子串后，依次找到长度为3的子串、长度为4的子串，直到找到长度为N的子串，即恢复。具体来讲，每次找到长度为2的子串后，将末尾字符恢复到前面，再对字符串做排序 ，排序后新的这些子串的末位字母就是题目给出的最后一位的字母，以此类推，直至获取长度为N的子串。

```python
class Solution:
    def strSort(self, lst):
        lst_temp, i = lst, 1
        while i < len(lst):
            lst_sort = lst_temp[:]
            lst_sort.sort()
            lst_temp = [lst[j]+lst_sort[j] for j in range(len(lst))]
            i += 1
        lst_temp.sort()
        print(lst_temp[0])
        return lst_temp[0]
        
sl = Solution()
sl.strSort(['C','B','A','A','C','B'])
```
